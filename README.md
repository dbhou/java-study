java学习笔记
=======
#一、java环境搭建
##1.jdk
-->了解目录结构<br/>
----->bin<br/>
----->src.zip<br/>
----->lib目录下是jar包<br/>
----->jre  运行环境<br/>
-------->lib/rt.jar<br/>
----->一个java应用程序<br/>
---------->类名一般就是文件名，如果类是public 类名就必须是文件名。<br/>
---------->一般来说一个类就是一个文件。<br/>
--------->编译<br/>
----------->javac命令<br/>
--------->设置环境变量path<br/>
--------->进入.java文件所在的目录<br/>
--------->javac 文件名.java<br/>
---------------->产生.class --->java字节码（包含了javacpu-->jvm的指令)<br/>

  ------>运行<br/>
-------- ---->java 类名<br/>
-------- ---->classpath环境变量<br/>
--------------------->寻找类的路径<br/>
--------  ----->默认是点代表当前目录<br/>
-------->jvm类加载机制<br/>
--------  ----->jvm是通过类加载器机制加载类的<br/>
--------------------->根类加载器<br/>
--------------------->负责加载jre/lib/rt.jar中的类<br/>
-------- ----->扩展类加载器<br/>
--------------------->负责加载jre/lib/ext/*.jar中的类<br/>
-------- ----->应用类加载器<br/>
---------------- ---->负责加载classpath下能找到的类<br/>
-------- ------>加载类的时候总是先从根类加载器找类，没有才去扩展类加载器，扩展没有才去应用类加载器<br/>

------->包的概念  <br/>
---- ----->包名是类名的一部分<br/>
----  ---->javac -d . 类名.java---- 自动生成包。<br/>


------->eclipse工具<br/>
--------->先安装jdk<br/>
--------->下载eclipse (for jee)<br/>

#二、java语法基础
##1.数据类型是强类型的
##2.数组
##3.在哪个{}声明的作用域就在哪个{}内

#三、java的面向对象
----->类<br/>
---------->相同属性（变量）、相似行为（函数）的抽象<br/>
---------->抽取人类<br/>
-------- ----->h,w<br/>
-------- ----->eat(),walk()<br/>
---- ----->抽取钟类<br/>
-------- ----->h,m,s<br/>
-------- ----->showTime();<br/>

----->对象<br/>
---- ----->类的实例<br/>
----->构造函数<br/><br/>
----  ----->函数名与类名相同，无任何返回类型<br/>
----  ----->创建对象的时候会自动调用，创建一次对象就会调用一次<br/>
----  ----->一般是用来给成员变量进行初始化的<br/>
----  ----->如果没有给出构造函数，jvm会给一个默认的无参数的构造函数<br/>
---------------- public 类名(){}<br/>
--------  一旦给了构造函数这个默认无参数的就不存在了。<br/>

----->函数重载<br/>
---- ----->同一个类中的一组函数，函数名称相同<br/>
---- ------>形式参数不同<br/>
---- ------>与返回值类型无关<br/>
---- ------>把这样的一组函数称为函数重载<br/>
---- ------>调用的时候会根据参数的类型和个数自动匹配决定调用哪个函数<br/>
---------------->这种匹配先找最精确的，如果没有找匹配得上的。<br/>
---------->补充：可变参数，可变参数必须是参数的最后一个，当做数组处理<br/>

------->访问权限<br/>
---- ----->public <br/>
------------  ---->修饰类和成员<br/>
------------>在不同包下访问<br/>
---- ----->默认的<br/>
------------ ----->修饰类和成员<br/>
----  ----->在同一包下访问<br/>
---- ----->private <br/>
------------ ----->只能在类的内部访问<br/>
----  ----->一般用来修饰成员变量<br/>
------>this引用<br/>
----  ----->当前对象（的引用）<br/>
----  ----->调用这个函数的那个对象（的引用）<br/>
----  ----->非静态的成员函数访问非静态的成员都省略了<br/>
----  ----->this(参数）<br/>
------------ ----->调用重载的另外一个构造函数<br/>

------>初始化的问题<br/>
----  ------>给成员变量直接初始化就是定义初始化<br/>
------------  ----->先定义初始化再构造函数 <br/>
----  ------>静态的成员变量<br/>
------------  ---->所有对象公用一份<br/>
------------>可以通过对象.访问(不建议），也可以类.访问<br/>
----  ------>静态定义初始化（静态定义初始化块）<br/>
------------ ----->用到一个类就会加载器静态成员属性<br/>
----  ----->且只加载一次<br/>
----  ------>静态的成员函数<br/>
------------ ---->可以使用类名直接调用，对象调用也可以不建议<br/>
----  ---->静态的成员函数只能访问静态的成员<br/>
  ----->练习1：写一个矩形类（左上角坐标，宽度、高度）<br/>
----------------------------  判断一个点是不是在矩形内<br/>
---------------- 求面积、求周长，让使用者更方便的使用<br/>
<br/>
<br/>
------->继承<br/>
--------->体现代码的复用<br/>
--------->使用extends关键字<br/>
--------->子类的构造函数会去掉用父类的构造函数<br/>
------------  ----->如果没有显示去调用父类的构造函数，默认就调用父类无参数的构造函数<br/>
--------->方法的重写or覆盖<br/>
--------->动态绑定<br/>
----------------->父类的引用引用了子类的对象<br/>
--------------->面向对象的语言都可以是父类的引用引用任何子类的实例<br/>
----  ----->调用方法的时候，如果方法构成重写，调用子类的方法。<br/>
--------->java中只能单一继承，java中的继承具有传递性<br/>
--------  ---->java中如果一个类没有父类，父类就是Object<br/>
------------->java.lang.Object类是一起类的父类<br/>
  ------>总体的初始化顺序（有父类有子类）<br/>
-------- ----->用到类先父类静态，再子类静态且只一次<br/>
-------- ----->然后是父类的定义初始化，父类的构造函数<br/>
-------- ----->最后是子类的定义初始化，子类的构造函数<br/>

------->抽象类<br/>
----  ----->抽象方法的概念<br/>
------------ ----->一个方法只有声明没有实现，就是抽象方法必须用abstract关键字声明<br/>
----  ----->如果一个类中有抽象方法，那么该类就是抽象类，必须用abstract声明<br/>
------------>抽象类不能直接实例化，但是可以实例化子类的对象<br/>
<br/>
#总结:
----->环境搭建<br/>
---- ----->用记事本写代码测试classpath环境变量，包，访问权限。<br/>
----->java的数据类型<br/>
---------->基本数据类型----  char,boolean,其它<br/>
---------->数组的使用<br/>
---------->可变参数<br/>
------>函数重载<br/>
------>类和对象<br/>
--------->构造函数<br/>
--------->构造函数的重载<br/>
--------->this引用<br/>
--------->定义初始化（定义初始化块）<br/>
--------->静态成员变量<br/>
------------ ----->静态定义初始化<br/>
----  ---->静态定义初始化块<br/>
---- ----->静态成员函数<br/>

------->继承<br/>
---- ----->继承中的构造函数问题<br/>
---- ----->方法重写（覆盖）<br/>
---- ----->动态绑定<br/>
---- ----->初始化顺序<br/>

------->抽象类<br/>

------->eclipse<br/>
---------------->快捷键----alt+/<br/>
---- ---->导入项目<br/>
--------------->File--->import---->General---->Existing projects into..--->bowser--->选中项目--->确定--->finish<br/>
--------------->如果jre报错<br/>
-------------------->右击项目--->Properties---->Java Builder Path--->右边选项卡选择Libraries--->选中jre----->remove<br/>
-------- ---->add lib --->Jre system lib---->next--->... <br/>
<br/><br/><br/>
#接口<br/>
------>接口体现的是一种标准<br/>
---------- ----->统一行为<br/>
 ------>用interface关键字声明<br/>
------------>内部声明的方法都是public abstract的即使你没有这样声明<br/>
 ------>标准的具体实现<br/>
------------>implements关键字<br/>
----- ---->实现接口（遵循标准）<br/>
------ ---->要重写接口中的方法<br/>
  ------->接口不能直接有实例，只能引用实现了该接口的类的实例<br/>
--------- ----->语法上理解为父类的引用引用了子类的对象<br/>
------->接口可以继承其它接口，并且可以多继承<br/>
<br/>
-------->内部类<br/>
-------------->成员内部类<br/>
-------------->静态内部类<br/>
-------------->局部内部类<br/>
------------ ----->看到函数的参数或者返回值类型是接口<br/>
---------------- ----->实现了这个接口的类的对象<br/>
----  ----->看到函数的参数或者返回值类型是抽象类<br/>
-------------------->继承了该抽象类的对象<br/>
----  ------->匿名内部类<br/>
--------------------->创建匿名内部类的对象<br/>
------------  ----->已知父类（普通类、抽象类、接口)<br/>
------------->要获取其子类的实例<br/>
------------->new 父类(){子类的实现部分}<br/>
<br/>
 <br/>
---->this<br/>
----  ---->当前对象的引用（调用这个函数的那个对象的引用)<br/>
----  ---->非静态的成员变量访问非静态的成员都省略了this<br/>
----  ---->this(参数）<br/>
----  ---->类名.this<br/>

#习1:定义一个接口CanFight 有fight方法<br/>
------------1.创建类实现该接口<br/>
---- 2.定义一个人类，声明一个方法返回值是CanFight<br/>
----  3.再声明一个方法参数类型是CanFight<br/>
----  4.使用匿名类的对象完成2，<br/>
----  5.在主函数中调用方法3使用匿名类的对象完成<br/>
------>final<br/>
-------- ---->修饰类，该类不能被继承<br/>
-------- ---->修饰方法，该方法不能被重写<br/>
-------- ----->修饰变量，变量只能赋值一次<br/>
<br/>
<br/>
#四、java集合专题(封装的数据结构的操作）<br/>
##1.java.util包下一些类的操作<br/>
------>Collection接口<br/>
-------- ----->List接口<br/><br/>
------------------------->ArrayList类<br/>
------------------------ ----->包装的是数组的操作<br/>
----------------  ---->插入元素、移除元素、扩容... ...<br/>
----------------->常用的API<br/>
---------------- ---->add方法、size方法，get(index)方法<br/>
---------------- ---->如何遍历（三种方式）<br/>
------------------------------------->注意点:<br/>
-------------------- ----->尽量预估大小避免扩容操作。<br/>
-------------------- ----->只要遇到以数组作为低层数据结构的，都要预估大小避免扩容。<br/>
------------ ----->LinkedList类<br/>
-------------------- ------>操作和ArrayList类似<br/>
------------  ------->封装链表的操作<br/>
------------  ------->头尾操作比较高效<br/>
---------------------------->提供了丰富的头尾操作的方法<br/>
-------- ----->Set接口<br/>
-------------------------->HashSet类<br/>
-------------------- ----->不能存放重复元素<br/>
------------  ----->重复元素如何定义<br/>
---------------------------->jvm默认就比较地址<br/>
---------------- ---->jvm提供了一种方式，让应用告诉JVM什么是重复对象<br/>
--------------------  ---->equals方法<br/>
-------------------->hashCode方法<br/>
-------------------->保证如果连个对象equals返回true,那么hashCode必须返回相同值<br/>
----------------  ------->TreeSet<br/>
----------------  ----->放进去的对象要能够进行排序<br/>
----------------->如何排序<br/>
----------------  ---->比较器java.util.Comparable<br/>
------------------------>compareTo方法如果放回0<br/>
------------------------>比较的两个对象equals为true<br/>
---------------->比较器java.util.Comparator<br/>

 ----->Map接口<br/>
--------  ------->HashMap(key/value)<br/>
-------- ---->基础API<br/>
----------------  ---->存，取，遍历<br/>
-------- ---->如果key相同value会覆盖<br/>
-------- ---->HashMap的数据结构（数组+链表）<br/>

#五、一些基础的常用类
##1.java.lang.Math
##2.静态导入
##3.java.util.Random
##4.java.util.UUID
##5.java.util.Date
##6.java.util.Calendar
##7.java.lang.String,java.lang.StringBuilder,java.langStringBuffer

-----------------------------12.5----------------------------------------------
#六、java异常处理
##1.类的结构
----->java.lang.Throwable<br/>
--------  ----->java.lang.Error<br/>
--------->java.lang.Exception<br/>
----->java中对所有的异常都进行了分门归类<br/>
--------  ----->产生任何一个异常都是一个类的具体实例<br/>
--------->Exception是一切异常的父类<br/>
----->Exception 又分为两类<br/>
-------- ----->一类如果程序不处理编译都不通过<br/>
-------- ----->另外一类可以程序不处理,jvm自动处理,<br/>
--------------------  ,也可以通过程序处理<br/>
-------- ---->java.lang.RuntimeException<br/>
##2.try,cache,finally
##3.异常常用的方法
  ---->getMessage()<br/>
  ---->toString()<br/>
  ---->printStackTrace();<br/>
 ##4.throw ,throws 关键字
 ------>throw<br/>
-------- ---->某个条件下人为制造出异常<br/>
-------- ---->throw 异常对象<br/>
<br/>
  ------>throws <br/>
-------- ----->回避异常<br/>
------------------------->有异常自己不处理，交给使用者处理<br/>
------------ ----->通过throws 回避异常以便通过编译，并告知使用者可能有这样的异常<br/>
------->自定义异常<br/>
-------- ------>创建一个类继承已有的异常类<br/>
 ------>子类重写父类方法时，不能throws 比父类更多的异常，<br/>
------------  ----->除非该异常是RuntimeException类型的。<br/>
------------  ----->里式替换原则<br/>
--------------------  ----->任何父类都可以引用子类对象<br/>
--------------------->但是子类不能比父类有更多的约束。<br/>

#七、java io处理
##1.了解编码
------>utf-8,gbk,utf-16be<br/>
------>文件是什么编码序列，转换成字符串必须用该编码，否则就会出现乱码<br/>
##2.java.io.File类
------->基本的API操作查看帮助文档<br/>
---- ----->判断是否存在、是否是文件or目录<br/>
---- ----->创建<br/>
------->list方法<br/>
------->练习删除一个文件夹<br/>
----  ----->文件夹为空才能删除<br/>
----  ----->把删除的目录和文件打印到控制台<br/>

##3.输入、输出
------>字节流（以字节为单位进行读取）<br/>
---- ----->输入流<br/>
----------------  InputStream ----->read()<br/>
---------------- ---->FileInputStream<br/>
--------  ---->DataInputStream<br/>
---- ----->输出流<br/>
----------------  OutputStream----->write()<br/>
--------------------->FileOutputStream<br/>
-------- ----->DataOutputStream<br/>
---- ----->所有的字节流都是通过最原始的读写（一个字节一个字节）<br/>
----------------一步一步装饰而来。<br/>
----  ------>装饰模式<br/>
------------------------->在不改变原有代码的基础上，让功能不断强大<br/>
------------ ----->类型不变<br/>
--------
--------->字符流（以字符为单位进行读取）<br/>
--------  ----->只对文本文件。<br/>
--------->输出流<br/>
------------  ------>Writer<br/>
------------  ---->OutputStreamWriter<br/>
------------  ---->BufferedWriter/PrintWriter<br/>
------------  
--------->输入流<br/>
------------  ------>Reader<br/>
----------------->InputStreamReader<br/>
----------------->BufferedReader<br/>
------->标准的输入输出<br/>
---------->System.in<br/>
---- ----->System.out<br/>
##练习1：拷贝一个文本文件到另外一个目录
---- ----- 用一次读一行的字符流来进行操作<br/>

##4.对象序列化和反序列化
-------->就是把对象的状态保存起来就是序列化<br/>
-------->从保存的地方把对象恢复出来就是反序列化<br/>
-------->java.io.ObjectOutputStream<br/>
-------->java.io.ObjectInputStream<br/>
-------->java.io.Serializable<br/>
-------->transient修饰的属性就不会做虚拟机默认的序列化工作<br/>


#八、java的反射机制
##1.java.lang.Class类
------>Class Type 是类的类型<br/>
------>Class.for("类的全称")<br/>
---------------->动态加载类，在运行时刻加载类<br/>
------------ ---->只有一种方式Class.forName("字符串");<br/>
---- ---->静态加载是在编译时刻加载<br/>
-------------------->所有new的对象都是静态加载的<br/>

------>框架的原理<br/>
---- ----->框架是半成品，通过了编译。<br/>
---- ----->运行起来的时候需要调用我们写的类和方法<br/>
---- ----->框架出现的时候我们还没有写类和方法呢<br/>
---- ----->框架是如何调用我们的类和方法的呢?<br/>
---- ----->框架是在运行时刻动态加载我们的类，并创建对象，调用方法。<br/>
------------ ----->Class.forName("类名");<br/>

-------->int,double...----,void <br/>

-------->通过java.lang.Class可以获取类的所有信息<br/>
-------- --->要获取类的信息，先获取类的类类型<br/>

##2.java.lang.reflect.Method
------>如果获取一个方法<br/>
------>method.invoke()<br/>
##3.java.lang.reflect.Field
  ------->如果获取一个成员变量<br/>
  ------->field.get(obj)/field.set(obj,value)<br/>

  练习2：写一个方法public static void changeValue(Object object)
##4.数组的反射
##5.构造函数的反射

#九、java多线程
##1.如何创建线程
--->第一种方式<br/>
   ------->创建一个类实现Runnable接口<br/>
   ------->以实现了Runnable接口的类的对象作为创建Thread类对象的构造函数的参数<br/>
---->主函数本身就是一个线程<br/>
----->第二种方式<br/>
   ----->创建一个类继承Thread<br/>
   ----->从写run方法<br/>



#JDBC,设计模式
