一、java环境搭建
1.jdk
----->了解目录结构
   ---->bin
   ---->src.zip
   ---->lib目录下是jar包
   ---->jre  运行环境
        ---->lib/rt.jar
------>一个java应用程序
   ------>类名一般就是文件名，如果类是public 类名就必须是文件名。
   ------>一般来说一个类就是一个文件。
   ----->编译
         ---->javac命令
	 ---->设置环境变量path
	 ---->进入.java文件所在的目录
	 ---->javac 文件名.java
	      ---->产生.class --->java字节码（包含了javacpu-->jvm的指令)
         
  ------>运行
       ---->java 类名
       ---->classpath环境变量
             ----->寻找类的路径
	     ----->默认是点代表当前目录
	---->jvm类加载机制
	     ----->jvm是通过类加载器机制加载类的
	         ----->根类加载器
		      ----->负责加载jre/lib/rt.jar中的类
		 ----->扩展类加载器
		      ----->负责加载jre/lib/ext/*.jar中的类
		 ----->应用类加载器
		       ---->负责加载classpath下能找到的类
	    ------>加载类的时候总是先从根类加载器找类，没有才去扩展类加载器，扩展没有才去应用类加载器

------->包的概念  
    ----->包名是类名的一部分
     ---->javac -d . 类名.java    自动生成包。


------->eclipse工具
   ----->先安装jdk
   ----->下载eclipse (for jee)



二、java语法基础
1.数据类型是强类型的
2.数组
3.在哪个{}声明的作用域就在哪个{}内

三、java的面向对象
----->类
   ------>相同属性（变量）、相似行为（函数）的抽象
   ------>抽取人类
       ----->h,w
       ----->eat(),walk()
    ----->抽取钟类
       ----->h,m,s
       ----->showTime();
         
----->对象
    ----->类的实例
----->构造函数
     ----->函数名与类名相同，无任何返回类型
     ----->创建对象的时候会自动调用，创建一次对象就会调用一次
     ----->一般是用来给成员变量进行初始化的
     ----->如果没有给出构造函数，jvm会给一个默认的无参数的构造函数
             public 类名(){}
	     一旦给了构造函数这个默认无参数的就不存在了。

----->函数重载
    ----->同一个类中的一组函数，函数名称相同
    ------>形式参数不同
    ------>与返回值类型无关
    ------>把这样的一组函数称为函数重载
    ------>调用的时候会根据参数的类型和个数自动匹配决定调用哪个函数
         ---->这种匹配先找最精确的，如果没有找匹配得上的。
   ------>补充：可变参数，可变参数必须是参数的最后一个，当做数组处理

------->访问权限
    ----->public 
           ---->修饰类和成员
	   ---->在不同包下访问
    ----->默认的
          ----->修饰类和成员
	  ----->在同一包下访问
    ----->private 
          ----->只能在类的内部访问
	  ----->一般用来修饰成员变量
------>this引用
     ----->当前对象（的引用）
     ----->调用这个函数的那个对象（的引用）
     ----->非静态的成员函数访问非静态的成员都省略了
     ----->this(参数）
          ----->调用重载的另外一个构造函数

------>初始化的问题
     ------>给成员变量直接初始化就是定义初始化
           ----->先定义初始化再构造函数 
     ------>静态的成员变量
           ---->所有对象公用一份
	   ---->可以通过对象.访问(不建议），也可以类.访问
     ------>静态定义初始化（静态定义初始化块）
          ----->用到一个类就会加载器静态成员属性
	  ----->且只加载一次
     ------>静态的成员函数
          ---->可以使用类名直接调用，对象调用也可以不建议
	  ---->静态的成员函数只能访问静态的成员
  ----->练习1：写一个矩形类（左上角坐标，宽度、高度）
                       判断一个点是不是在矩形内
		       求面积、求周长，让使用者更方便的使用


------->继承
   ----->体现代码的复用
   ----->使用extends关键字
   ----->子类的构造函数会去掉用父类的构造函数
           ----->如果没有显示去调用父类的构造函数，默认就调用父类无参数的构造函数
   ----->方法的重写or覆盖
   ----->动态绑定
         ----->父类的引用引用了子类的对象
	      --->面向对象的语言都可以是父类的引用引用任何子类的实例
	  ----->调用方法的时候，如果方法构成重写，调用子类的方法。
   ----->java中只能单一继承，java中的继承具有传递性
        ---->java中如果一个类没有父类，父类就是Object
	   ----->java.lang.Object类是一起类的父类
  ------>总体的初始化顺序（有父类有子类）
       ----->用到类先父类静态，再子类静态且只一次
       ----->然后是父类的定义初始化，父类的构造函数
       ----->最后是子类的定义初始化，子类的构造函数

------->抽象类
     ----->抽象方法的概念
          ----->一个方法只有声明没有实现，就是抽象方法必须用abstract关键字声明
	  ----->如果一个类中有抽象方法，那么该类就是抽象类，必须用abstract声明
      ---->抽象类不能直接实例化，但是可以实例化子类的对象



总结:
----->环境搭建
    ----->用记事本写代码测试classpath环境变量，包，访问权限。
----->java的数据类型
   ------>基本数据类型     char,boolean,其它
   ------>数组的使用
   ------>可变参数
------>函数重载
------>类和对象
   ----->构造函数
   ----->构造函数的重载
   ----->this引用
   ----->定义初始化（定义初始化块）
   ----->静态成员变量
          ----->静态定义初始化
	  ---->静态定义初始化块
    ----->静态成员函数

------->继承
    ----->继承中的构造函数问题
    ----->方法重写（覆盖）
    ----->动态绑定
    ----->初始化顺序

------->抽象类

------->eclipse
         ---->快捷键   alt+/
	 ---->导入项目
	      --->File--->import---->General---->Existing projects into..--->bowser--->选中项目--->确定--->finish
	      --->如果jre报错
	         ---->右击项目--->Properties---->Java Builder Path--->右边选项卡选择Libraries--->选中jre----->remove
		 ---->add lib --->Jre system lib---->next--->... 


---------------------------------------12-4-------------------------------------------------
----------->接口
     ------>接口体现的是一种标准
             ----->统一行为
     ------>用interface关键字声明
         ----->内部声明的方法都是public abstract的即使你没有这样声明
     ------>标准的具体实现
               ---->implements关键字
	       ---->实现接口（遵循标准）
	       ---->要重写接口中的方法
     ------->接口不能直接有实例，只能引用实现了该接口的类的实例
             ----->语法上理解为父类的引用引用了子类的对象
     ------->接口可以继承其它接口，并且可以多继承

-------->内部类
      ------>成员内部类
      ------>静态内部类
      ------>局部内部类
          ----->看到函数的参数或者返回值类型是接口
	          ----->实现了这个接口的类的对象
	  ----->看到函数的参数或者返回值类型是抽象类
	         ---->继承了该抽象类的对象
     ------->匿名内部类
            ----->创建匿名内部类的对象
	        ----->已知父类（普通类、抽象类、接口)
		----->要获取其子类的实例
		----->new 父类(){子类的实现部分}
       
 
---->this
     ---->当前对象的引用（调用这个函数的那个对象的引用)
     ---->非静态的成员变量访问非静态的成员都省略了this
     ---->this(参数）
     ---->类名.this

练习1:定义一个接口CanFight 有fight方法
         1.创建类实现该接口
	 2.定义一个人类，声明一个方法返回值是CanFight
	  3.再声明一个方法参数类型是CanFight
	  4.使用匿名类的对象完成2，
	  5.在主函数中调用方法3使用匿名类的对象完成
------>final
       ---->修饰类，该类不能被继承
       ---->修饰方法，该方法不能被重写
       ----->修饰变量，变量只能赋值一次


四、java集合专题(封装的数据结构的操作）
1.java.util包下一些类的操作
------>Collection接口
       ----->List接口
               ----->ArrayList类
	                ----->包装的是数组的操作
			     ---->插入元素、移除元素、扩容... ...
			----->常用的API
			    ---->add方法、size方法，get(index)方法
			    ---->如何遍历（三种方式）
                        ----->注意点:
			       ----->尽量预估大小避免扩容操作。
			       ----->只要遇到以数组作为低层数据结构的，都要预估大小避免扩容。
	       ----->LinkedList类
	             ------>操作和ArrayList类似
		     ------->封装链表的操作
		     ------->头尾操作比较高效
		            ---->提供了丰富的头尾操作的方法
       ----->Set接口
               ------>HashSet类
	             ----->不能存放重复元素
		     ----->重复元素如何定义
		            ---->jvm默认就比较地址
			    ---->jvm提供了一种方式，让应用告诉JVM什么是重复对象
			        ---->equals方法
				---->hashCode方法
				---->保证如果连个对象equals返回true,那么hashCode必须返回相同值
              ------->TreeSet
	           ----->放进去的对象要能够进行排序
		   ----->如何排序
		        ---->比较器java.util.Comparable
			      ---->compareTo方法如果放回0
			      ---->比较的两个对象equals为true
			---->比较器java.util.Comparator
	          
 ----->Map接口
        ------->HashMap(key/value)
	    ---->基础API
	           ---->存，取，遍历
	    ---->如果key相同value会覆盖
	    ---->HashMap的数据结构（数组+链表）

五、一些基础的常用类
1.java.lang.Math
2.静态导入
3.java.util.Random
4.java.util.UUID
5.java.util.Date
6.java.util.Calendar
7.java.lang.String,java.lang.StringBuilder,java.langStringBuffer

-----------------------------12.5----------------------------------------------
六、java异常处理
1.类的结构
----->java.lang.Throwable
        ----->java.lang.Error
	----->java.lang.Exception
----->java中对所有的异常都进行了分门归类
        ----->产生任何一个异常都是一个类的具体实例
	----->Exception是一切异常的父类
----->Exception 又分为两类
       ----->一类如果程序不处理编译都不通过
       ----->另外一类可以程序不处理,jvm自动处理,
                 ,也可以通过程序处理
		 ---->java.lang.RuntimeException
2.try,cache,finally
3.异常常用的方法
  ---->getMessage()
  ---->toString()
  ---->printStackTrace();
 4.throw ,throws 关键字
 ------>throw
       ---->某个条件下人为制造出异常
       ---->throw 异常对象

  ------>throws 
       ----->回避异常
               ----->有异常自己不处理，交给使用者处理
	       ----->通过throws 回避异常以便通过编译，并告知使用者可能有这样的异常
------->自定义异常
       ------>创建一个类继承已有的异常类
 ------>子类重写父类方法时，不能throws 比父类更多的异常，
           ----->除非该异常是RuntimeException类型的。
           ----->里式替换原则
	              ----->任何父类都可以引用子类对象
		      ----->但是子类不能比父类有更多的约束。


七、java io处理
1.了解编码
------>utf-8,gbk,utf-16be
------>文件是什么编码序列，转换成字符串必须用该编码，否则就会出现乱码
2.java.io.File类
------->基本的API操作查看帮助文档
    ----->判断是否存在、是否是文件or目录
    ----->创建
------->list方法
------->练习删除一个文件夹
     ----->文件夹为空才能删除
     ----->把删除的目录和文件打印到控制台

3.输入、输出
------>字节流（以字节为单位进行读取）
    ----->输入流
              InputStream ----->read()
	          ---->FileInputStream
		  ---->DataInputStream
    ----->输出流
              OutputStream----->write()
	         ----->FileOutputStream
		 ----->DataOutputStream
    ----->所有的字节流都是通过最原始的读写（一个字节一个字节）
            一步一步装饰而来。
     ------>装饰模式
               ----->在不改变原有代码的基础上，让功能不断强大
	       ----->类型不变
	   
--------->字符流（以字符为单位进行读取）
        ----->只对文本文件。
	----->输出流
	        ------>Writer
		     ---->OutputStreamWriter
		     ---->BufferedWriter/PrintWriter
		     
	----->输入流
	        ------>Reader
		   ----->InputStreamReader
		   ----->BufferedReader
------->标准的输入输出
         ----->System.in
	 ----->System.out
练习1：拷贝一个文本文件到另外一个目录
             用一次读一行的字符流来进行操作

4.对象序列化和反序列化
-------->就是把对象的状态保存起来就是序列化
-------->从保存的地方把对象恢复出来就是反序列化
-------->java.io.ObjectOutputStream
-------->java.io.ObjectInputStream
-------->java.io.Serializable
-------->transient修饰的属性就不会做虚拟机默认的序列化工作


八、java的反射机制
1.java.lang.Class类
------>Class Type 是类的类型
------>Class.for("类的全称")
         ---->动态加载类，在运行时刻加载类
	       ---->只有一种方式Class.forName("字符串");
	 ---->静态加载是在编译时刻加载
	         ---->所有new的对象都是静态加载的

------>框架的原理
    ----->框架是半成品，通过了编译。
    ----->运行起来的时候需要调用我们写的类和方法
    ----->框架出现的时候我们还没有写类和方法呢
    ----->框架是如何调用我们的类和方法的呢?
    ----->框架是在运行时刻动态加载我们的类，并创建对象，调用方法。
          ----->Class.forName("类名");

-------->int,double...   ,void 

-------->通过java.lang.Class可以获取类的所有信息
       --->要获取类的信息，先获取类的类类型


2.java.lang.reflect.Method
------>如果获取一个方法
------>method.invoke()
3.java.lang.reflect.Field
  ------->如果获取一个成员变量
  ------->field.get(obj)/field.set(obj,value)

  练习2：写一个方法public static void changeValue(Object object)
4.数组的反射
5.构造函数的反射

九、java多线程
1.如何创建线程
--->第一种方式
   ------->创建一个类实现Runnable接口
   ------->以实现了Runnable接口的类的对象作为创建Thread类对象的构造函数的参数
---->主函数本身就是一个线程
----->第二种方式
   ----->创建一个类继承Thread
   ----->从写run方法



   ------->JDBC,设计模式
